#!/usr/bin/python2
import numpy as _n, socket as _s, struct as _p

""" STATE CONSTANTS """

# state[0]:error, state[1]:ok
STATE_IDLE   = [  6,  7]
STATE_ARMED  = [ 14, 15]
STATE_DELAY  = [ 22, 23]
STATE_SAMPLE = [114,115]
STATE_LOW    = [ 82, 83]
STATE_HIGH   = [210,211]
STATE_REPEAT = [ 50, 51]

""" DEVICE """

try:
  from MDSplus import Device
  class W7X_TIMING(Device) :
    parts=[
           {'path': ':ACTIONSERVER',                'type': 'TEXT',    'options':('no_write_shot','write_once')},
           {'path': ':ACTIONSERVER:INIT',           'type': 'ACTION',  'options':('no_write_shot','write_once'), 'valueExpr':'Action(node.DISPATCH,node.TASK)'},
           {'path': ':ACTIONSERVER:INIT:DISPATCH',  'type': 'DISPATCH','options':('no_write_shot','write_once'), 'valueExpr':'Dispatch(head.actionserver,"INIT",21)'},
           {'path': ':ACTIONSERVER:INIT:TASK',      'type': 'TASK',    'options':('no_write_shot','write_once'), 'valueExpr':'Method(None,"init",head)'},
           {'path': ':ACTIONSERVER:ARM',            'type': 'ACTION',  'options':('no_write_shot','write_once'), 'valueExpr':'Action(node.DISPATCH,node.TASK)'},
           {'path': ':ACTIONSERVER:ARM:DISPATCH',   'type': 'DISPATCH','options':('no_write_shot','write_once'), 'valueExpr':'Dispatch(head.actionserver,"INIT",51)'},
           {'path': ':ACTIONSERVER:ARM:TASK',       'type': 'TASK',    'options':('no_write_shot','write_once'), 'valueExpr':'Method(None,"arm",head)'},
           {'path': ':ACTIONSERVER:TRIG',           'type': 'ACTION',  'options':('no_write_shot','write_once'), 'valueExpr':'Action(node.DISPATCH,node.TASK)'},
           {'path': ':ACTIONSERVER:TRIG:DISPATCH',  'type': 'DISPATCH','options':('no_write_shot','write_once'), 'valueExpr':'Dispatch(head.actionserver,"PULSE",1)'},
           {'path': ':ACTIONSERVER:TRIG:TASK',      'type': 'TASK',    'options':('no_write_shot','write_once'), 'valueExpr':'Method(None,"trig",head)'},
           {'path': ':ACTIONSERVER:DISARM',         'type': 'ACTION',  'options':('no_write_shot','write_once'), 'valueExpr':'Action(node.DISPATCH,node.TASK)'},
           {'path': ':ACTIONSERVER:DISARM:DISPATCH','type': 'DISPATCH','options':('no_write_shot','write_once'), 'valueExpr':'Dispatch(head.actionserver,"DEINIT",21)'},
           {'path': ':ACTIONSERVER:DISARM:TASK',    'type': 'TASK',    'options':('no_write_shot','write_once'), 'valueExpr':'Method(None,"disarm",head)'},
           {'path': ':ACTIONSERVER:REINIT',         'type': 'TASK',    'options':('no_write_shot','write_once'), 'valueExpr':'Method(None,"reinit",head,(head.DELAY))'},
           {'path': ':ACTIONSERVER:REINIT:DELAY',   'type': 'NUMERIC', 'options':('no_write_shot'),              'valueExpr':'Uint64(60).setUnits("s")', 'help':"time after trigger to wait for program upload"},
           {'path': ':SERVER',                      'type': 'TEXT',    'options':('no_write_shot','write_once')},
           {'path': ':COMMENT',                     'type': 'TEXT'},
           {'path': ':CLOCK',                       'type': 'NUMERIC', 'options':('no_write_shot','write_once'), 'valueExpr':'Uint32(100 ).setUnits("ns")', 'help':"Internal clock runs at 10MHz."},
           {'path': ':TRIGGER',                     'type': 'NUMERIC', 'options':('no_write_shot','write_once'), 'valueExpr': 'Int64(  0 ).setUnits("s")'},
           {'path': ':INVERT'  ,                    'type': 'NUMERIC', 'options':('no_write_shot',), 'valueExpr':'Uint8Array([1,3,5])', 'help':"list of outputs [0..5] that should have an inverted signal"},
           {'path': ':GATE',                        'type': 'NUMERIC', 'options':('no_write_shot',), 'valueExpr':'Uint8Array([2,3])', 'help':"list of outputs [0..5] that should have the gate instead of the trigger signal"},
           {'path': ':GATE2',                       'type': 'NUMERIC', 'options':('no_write_shot',), 'valueExpr':'Uint8Array([4,5])', 'help':"list of outputs [0..5] that should be a gat that opens and closes every other trigger"},
           {'path': ':DELAY',                       'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Int64(0).setUnits("s")'},
           {'path': ':WIDTH',                       'type': 'NUMERIC', 'options':('no_write_shot',),             'value':None},
           {'path': ':PERIOD',                      'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Uint64(  1 ).setUnits("us")'},
           {'path': ':BURST',                       'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Uint64( 1e3)'},
           {'path': ':CYCLE',                       'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Uint64(  1 ).setUnits("s")'},
           {'path': ':REPEAT',                      'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Uint32(  1 )'},
           {'path': ':TIMING',                      'type': 'NUMERIC', 'options':('no_write_shot',),             'valueExpr':'Uint64Array([0]).setUnits("us")', 'help':"Empty for clock\\nArray for sequence"},
          ]

    units_ns = {'ns':1, 'us':1000, 'ms':1000000, 's':1000000000}
    _com = None
    @property
    def com(self):
        if self._com is None:
            self._com = remote(self._server)
        return self._com
    @property
    def _clock(self):
        rec = self.clock.getRecord(None)
        if rec is None: return 100
        value = rec.data()
        units = str(rec.getUnits()).strip().lower()
        return value * self.units_ns.get(units,1)
    def _toticks(self,node):
        try:
            rec = node.getRecord(None)
            if rec is None: return None
            units = str(rec.getUnits()).strip().lower()
            value = rec.data()
            if self.units_ns.has_key(units):
                value = value * self.units_ns[units] / self._clock
            return value.tolist()
        except:
            import traceback
            traceback.print_exc()
            return None
    @property
    def _server(self): return str(self.server.data())
    @property
    def _gate(self):   return self.gate.data().tolist()
    @property
    def _gate2(self):  return self.gate2.data().tolist()
    @property
    def _invert(self): return self.invert.data().tolist()
    @property
    def _delay(self):  return self._toticks(self.delay)
    @property
    def _period(self): return self._toticks(self.period)
    @property
    def _width(self):  return self._toticks(self.width)
    @property
    def _burst(self):  return int(self.burst.data())
    @property
    def _cycle(self):  return self._toticks(self.cycle)
    @property
    def _repeat(self): return int(self.repeat.data())
    @property
    def _timing(self): return self._toticks(self.timing)
    def arm(self):
        self.com.arm()
    def trig(self):
        self.com.trig()
    def disarm(self):
        self.com.disarm()
    def init(self):
        self.com.gate(self._gate)
        self.com.gate2(self._gate2)
        self.com.invert(self._invert)
        print(self.com.makeSequence(self._delay,self._width,self._period,self._burst,self._cycle,self._repeat,self._timing))
    def reinit(self,delay):
        self.com.reinit(self.toticks(delay))
        self.com.arm()
except: pass

""" REMOTE CONNECTION """

class remote(object):
    @staticmethod
    def _tobyte(val):
        if not isinstance(val,int):
            value = 0;
            for ch in val: value |= 4<<ch
            return value
        return val
    @staticmethod
    def _makeMsg(prog,form,length,*args):
        return 'W7X'+_p.pack('<L',length)+prog[0]+_p.pack(form,*args)
    def __init__(self,address):
        host = address.split(':',2)+[5000]
        port = int(host[1])
        self._address = (host[0],port)
        self.connect()
    def connect(self):
        self.sock = _s.socket(_s.AF_INET, _s.SOCK_STREAM)
        self.sock.connect(self._address)
        self.sock.settimeout(3)
    def _exchange(self,msg,force_str=False):
        def _tryexchange(msg):
            self.sock.send(msg)
            ret = self.sock.recv(4)
            if len(ret)<4: raise _s.error
            length = _p.unpack('<L',ret)[0]
            if length>0:
                return self.sock.recv(length+255)
        try:
            ans = _tryexchange(msg)
        except _s.error:
            self.connect()
            ans = _tryexchange(msg)
        if force_str:
            return '' if ans is None else ans
        return self if ans is None else ans
    @staticmethod
    def _tointargs(*args):
        return tuple((int(arg) if arg is not None else -1) for arg in args)
    def makeClock(self,delay=-1,width=-1,period=-1,burst=-1,cycle=-1,repeat=-1):
        args= remote._tointargs(delay,width,period,burst,cycle,repeat)
        msg = remote._makeMsg('C','<qqqqql',44,*args)
        return self._exchange(msg)
    def makeSequence(self,delay=-1,width=-1,period=-1,burst=-1,cycle=-1,repeat=-1,timing=-1):
        timing = _n.array(timing,_n.int64).tostring()
        length = len(timing)+44
        args= remote._tointargs(delay,width,period,burst,cycle,repeat)
        msg = remote._makeMsg('S','<qqqqql',length,*args)+timing
        return self._exchange(msg)
    def arm(self):
        msg = remote._makeMsg('A','',0)
        return self._exchange(msg)
    def rearm(self):
        msg = remote._makeMsg('R','',0)
        return self._exchange(msg)
    def reinit(self,default_delay=-1):
        msg = remote._makeMsg('X','<q',8,default_delay)
        return self._exchange(msg)
    def disarm(self):
        msg = remote._makeMsg('D','',0)
        return self._exchange(msg)
    def trig(self):
        msg = remote._makeMsg('T','',0)
        return self._exchange(msg)
    def extclk(self,value=True):
        msg = remote._makeMsg('E','<b',1,1 if value else 0)
        return self._exchange(msg)
    def gate(self,val=0):
        msg = remote._makeMsg('G','<B',1,self._tobyte(val))
        return self._exchange(msg)
    def gate2(self,val=0):
        msg = remote._makeMsg('H','<B',1,self._tobyte(val))
        return self._exchange(msg)
    def invert(self,val=0):
        msg = remote._makeMsg('I','<B',1,self._tobyte(val))
        return self._exchange(msg)
    @property
    def state(self):
        self.sock.send(remote._makeMsg('s','',0))
        return _p.unpack('<B',self.sock.recv(1))[0]
    @property
    def control(self):
        self.sock.send(remote._makeMsg('c','',0))
        return _p.unpack('<BBBBBBBB',self.sock.recv(8))
    @property
    def params(self):
        self.sock.send(remote._makeMsg('p','',0))
        return _p.unpack('<qqqqqll',self.sock.recv(48))
    @property
    def error(self):
        msg = remote._makeMsg('e','',0)
        return self._exchange(msg,True)
    @property
    def has_ext_clk(self):
        if self.state != STATE_IDLE[1]:
            raise Exception("You should disarm the device first.\nCurrent state: %d",self.state)
        from time import sleep
        self.disarm()
        self.extclk(0)
        idle = self.state
        self.makeClock(1e7)
        self.extclk(1)
        self.arm()
        sleep(0.01)
        hasext = self.state != idle
        self.extclk(0)
        self.disarm()
        return hasext

""" UNIT TEST """

import unittest as _u
class Test(_u.TestCase):
    def connect(self):
        import time
        dev = remote(Test._host)
        dev.disarm();
        if dev.has_ext_clk:
            print("test using external clock.")
            dev.extclk(1)
        dev.reinit(),
        self.assertEqual(dev.error.strip(),"MAKE CLOCK: DELAY: 600000000, WIDTH: 5, PERIOD: 10, BURST: 0, CYCLE: 0, REPEAT: 0, COUNT: 1")
        time.sleep(.1)
        dev.disarm();
        dev.makeClock(cycle=10000000,burst=1000,repeat=5)
        self.assertEqual(dev.error.strip(),"MAKE CLOCK: DELAY: 0, WIDTH: 5, PERIOD: 10, BURST: 1000, CYCLE: 10000000, REPEAT: 5, COUNT: 1")
        self.assertEqual(dev.params,(0,5,10,1000,10000000,5,1))
        dev.makeSequence(1e6,5,10,100,1e6,3,[0,2e4,4e4,5e4,7e4,1e5])
        self.assertEqual(dev.error.strip(),"MAKE SEQUENCE: TIMES: [0, 20000, 40000, 50000, 70000, 100000],\nDELAY: 1000000, WIDTH: 5, PERIOD: 10, BURST: 100, CYCLE: 1000000, REPEAT: 3, COUNT: 6")
        dev.gate([2,4])
        dev.gate2([5])
        dev.invert([3,4])
        self.assertEqual(dev.state,STATE_IDLE[1])
        dev.arm()
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.rearm()
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.trig()
        self.assertEqual(dev.state,STATE_DELAY[1])
        time.sleep(1)
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.disarm()
        self.assertEqual(dev.state,STATE_IDLE[1])
    def runTest(self):
        self.connect()

def test(hostname=None):
    import os
    if hostname is None:
        Test._host = os.getenv('RedPitaya','localhost')
    else:
        Test._host = hostname
    suite=_u.TestSuite((Test('connect'),))
    tr=_u.TextTestRunner(stream=os.sys.stderr)
    tr.run(suite)

""" EXECUTION """

if __name__=="__main__":
    import sys
    if len(sys.argv)==1:
        test()
    elif len(sys.argv)==2:
        test(sys.argv[1])

