#!/usr/bin/python2
import ctypes as _c
import numpy as _n,socket as _s, struct as _p

""" STATE CONSTANTS """

# state[0]:error, state[1]:ok
STATE_IDLE   = [  6,  7]
STATE_ARMED  = [ 14, 15]
STATE_DELAY  = [ 22, 23]
STATE_SAMPLE = [114,115]
STATE_LOW    = [ 82, 83]
STATE_HIGH   = [210,211]
STATE_REPEAT = [ 50, 51]

""" SERVER INTERFACE """

class w7x_timing(object):
    _NULL = _c.c_void_p(None)
    @staticmethod
    def _tobyte(val):
        if not isinstance(val,int):
            value = 0;
            for ch in val: value |= 4<<ch
            return value
        return val
    @staticmethod
    def _toctypes(delay,width,period,burst,cycle,repeat,*args):
        delay  = None if delay  is None else _c.c_uint64(int(delay ))
        width  = None if width  is None else _c.c_uint64(int(width ))
        period = None if period is None else _c.c_uint64(int(period))
        burst  = None if burst  is None else _c.c_uint64(int(burst ))
        cycle  = None if cycle  is None else _c.c_uint64(int(cycle ))
        repeat = None if repeat is None else _c.c_uint32(int(repeat))
        if len(args)>0:
          count= None if args[0] is None else _c.c_uint32(int(args[0]))
          return (delay,width,period,burst,cycle,repeat,count)
        return (delay,width,period,burst,cycle,repeat)
    @staticmethod
    def _byref(*args):
        return tuple((w7x_timing._NULL if a is None else _c.byref(a)) for a in args)

    def __init__(self):
        try:
            self.cdll = _c.CDLL('libw7x_timing_lib.so')
            self.cdll.getError.restype=_c.c_void_p
            self._error = _c.cast(self.cdll.getError(),_c.c_char_p)
            if self.state == STATE_IDLE[1]: self.tryExt()
        except OSError as exc:
            print('w7x_timing: '+ str(exc))
            raise
    def tryExt(self):
        from time import sleep
        self.disarm()
        self.extclk(0)
        idle = self.state
        self.makeClock(1e7)
        self.extclk(1)
        self.arm()
        sleep(0.1)
        hasext = self.state != idle
        if not hasext: self.extclk(0)
        self.disarm()
        return hasext
    def arm(self):
        self.cdll.arm()
    def rearm(self):
        self.cdll.rearm()
    def disarm(self):
        self.cdll.disarm()
    def makeClock(self,delay=None,width=None,period=None,burst=None,cycle=None,repeat=None):
        args = w7x_timing._toctypes(delay,width,period,burst,cycle,repeat)
        delay,width,period,burst,cycle,repeat = w7x_timing._byref(*args)
        self.cdll.makeClock(delay,width,period,burst,cycle,repeat)
    def makeSequence(self,delay=None,width=None,period=None,burst=None,cycle=None,repeat=None,times=[]):
        times = _n.ascontiguousarray(times,dtype=_n.uint64)
        timref= times.ctypes.data_as(_c.POINTER(_c.c_uint64))
        args  = w7x_timing._toctypes(delay,width,period,burst,cycle,repeat,len(times))
        delay,width,period,burst,cycle,repeat,count = w7x_timing._byref(*args)
        self.cdll.makeSequence(delay,width,period,burst,cycle,repeat,count,timref)
    def reinit(self,delay=None):
        delay = None if delay  is None else _c.c_uint64(int(delay))
        ref   = w7x_timing._NULL if delay is None else _c.byref(delay)
        self.cdll.reinit(ref)
    def trig(self):
        self.cdll.trig()
    def extclk(self,value):
        self.cdll.extclk(_c.c_int8(-1) if value else _c.c_int8(0))
    def gate(self,value=0):
        value = _c.c_uint8(w7x_timing._tobyte(value))
        self.cdll.gate(value)
    def gate2(self,value=0):
        value = _c.c_uint8(w7x_timing._tobyte(value))
        self.cdll.gate2(value)
    def invert(self,value=0):
        value = _c.c_uint8(w7x_timing._tobyte(value))
        self.cdll.invert(value)
    @property
    def error(self):
        return str(self._error.value)
    @property
    def state(self):
        return self.cdll.getState()
    @property
    def params(self):
        args = w7x_timing._toctypes(0,0,0,0,0,0,0)
        refs = w7x_timing._byref(*args)
        self.cdll.getParams(*refs)
        return tuple(int(a.value) for a in args)

    def run(self,port):
        def senderror(conn):
            msg = str(self.error)
            conn.send(_p.pack('<L',len(msg))+msg)
        try: #create an AF_INET, STREAM socket (TCP)
            sock = _s.socket(_s.AF_INET, _s.SOCK_STREAM)
        except _s.error as msg:
            print 'Failed to create socket. Error code: ' + str(msg[0]) + ' , Error message : ' + msg[1]
            return
        try:
            sock.bind(('', int(port)))
        except _s.error as msg:
            print 'Bind failed. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
            return
        try:
            sock.listen(5)
        except _s.error as msg:
            print 'Listen failed. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
            return
        while True:
            try:
                conn, addr = sock.accept()
                print('%s: Connection established'%(addr[0],))
                conn.settimeout(10)
                while True:
                    try:
                        head = conn.recv(7)
                        if not head.startswith('W7X'):
                            if len(head)>0:
                                raise Exception('%s: Invalid header "%s"'%(addr[0],head))
                            raise Exception('%s: Connection closed'%(addr[0],))
                        length = _p.unpack('<L',head[3:])[0]
                        remaining = length+1
                        cmd = []
                        while remaining>0:
                            cmd.append(conn.recv(remaining+256))
                            remaining-= len(cmd[-1])
                        cmd = ''.join(cmd)
                        cmd,param = cmd[0],cmd[1:]
                        if   cmd == 'C':
                            param = tuple((None if p<0 else p) for p in _p.unpack('<qqqqql',param[:44]))
                            self.makeClock(*param)
                        elif cmd == 'S':
                            args = tuple((None if p<0 else p) for p in _p.unpack('<qqqqql',param[:44]))
                            times = _n.fromstring(param[44:length],_n.uint64)
                            self.makeSequence(*args,times=times)
                        elif cmd == 'A':
                            self.arm()
                        elif cmd == 'R':
                            self.rearm()
                        elif cmd == 'X':
                            self.reinit([(None if p<0 else p) for p in _p.unpack('<q',param[:8])][0])
                        elif cmd == 'D':
                            self.disarm()
                        elif cmd == 'T':
                            self.trig()
                        elif cmd == 'E':
                            self.extclk(_p.unpack('<b',param[0])[0])
                        elif cmd == 'G':
                            self.gate(_p.unpack('<b',param[0])[0])
                        elif cmd == 'H':
                            self.gate2(_p.unpack('<b',param[0])[0])
                        elif cmd == 'I':
                            self.invert(_p.unpack('<b',param[0])[0])
                        elif cmd == 's':
                            conn.send(_p.pack('<L',self.state))
                            continue
                        elif cmd == 'p':
                            conn.send(_p.pack('<qqqqqll',*self.params))
                            continue
                        elif cmd == 'e':
                            pass #only return error
                        else:
                            raise Exception('%s: Invalid command "%s"'%(addr[0],cmd))
                        senderror(conn)
                    except KeyboardInterrupt:
                        conn.close()
                        del(conn)
                        raise
                    except Exception as e:
                        print(e)
                        conn.close()
                        del(conn)
                        break
            except KeyboardInterrupt:
                sock.close()
                raise
            except Exception as e:
                print(e)

""" UNIT TEST """

import unittest as _u
import time as _t
class Test(_u.TestCase):
    def local(self):
        dev = w7x_timing()
        dev.disarm();
        dev.reinit(),
        self.assertEqual(dev.error.strip(),"MAKE CLOCK: DELAY: 600000000, WIDTH: 5, PERIOD: 10, BURST: 0, CYCLE: 0, REPEAT: 0, COUNT: 1")
        _t.sleep(.1)
        dev.disarm();
        dev.makeClock(cycle=10000000,burst=1000,repeat=5)
        self.assertEqual(dev.error.strip(),"MAKE CLOCK: DELAY: 0, WIDTH: 5, PERIOD: 10, BURST: 1000, CYCLE: 10000000, REPEAT: 5, COUNT: 1")
        self.assertEqual(dev.params,(0,5,10,1000,10000000,5,1))
        dev.makeSequence(1e6,5,10,100,1e6,3,[0,2e4,4e4,5e4,7e4,1e5])
        self.assertEqual(dev.error.strip(),"MAKE SEQUENCE: TIMES: [0, 20000, 40000, 50000, 70000, 100000],\nDELAY: 1000000, WIDTH: 5, PERIOD: 10, BURST: 100, CYCLE: 1000000, REPEAT: 3, COUNT: 6")
        dev.gate([2,4])
        dev.gate2([5])
        dev.invert([3,4])
        self.assertEqual(dev.state,STATE_IDLE[1])
        dev.arm()
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.rearm()
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.trig()
        self.assertEqual(dev.state,STATE_DELAY[1])
        _t.sleep(1)
        self.assertEqual(dev.state,STATE_ARMED[1])
        dev.disarm()
        self.assertEqual(dev.state,STATE_IDLE[1])
    def runTest(self):
        self.local()

def test():
    import os
    suite=_u.TestSuite((Test('local'),))
    tr=_u.TextTestRunner(stream=os.sys.stderr)
    tr.run(suite)

""" EXECUTION """

if __name__=="__main__":
    import sys
    if len(sys.argv)>1:
        try:
            port = int(sys.argv[1])
            w7x_timing().run(port)
        except ValueError:
            test()
    else:
        w7x_timing().run(5000)

