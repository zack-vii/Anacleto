#!/usr/bin/python2
import ctypes
import numpy
import socket
import struct
import threading
import unittest

# STATE CONSTANTS
TIME_WIDTH = 40
INIT_DISARM = 0
INIT_ON = 1
INIT_ARM = 3
INIT_REARM = 7
INIT_REINIT = 15

MAX_STATUS = 8
MAX_SAMPLES = 54272

TIME_MASK = (1 << TIME_WIDTH) - 1

STATE_CH0 = 1
STATE_CH1 = 2
STATE_CH2 = 4
STATE_CH3 = 8
STATE_IDLE = 16
STATE_ARMED = 32
STATE_ACTIVE = 64
STATE_CLK = 128


class struct_rptrig(object):
    class _Device(ctypes.Structure):
        _fields_ = [
            ("status", ctypes.c_ubyte*8),
            ("statusx", ctypes.c_uint64*7),
            ("init", ctypes.c_ubyte),
            ("trig", ctypes.c_ubyte),
            ("clear", ctypes.c_ubyte),
            ("save", ctypes.c_ubyte),
            ("extclk", ctypes.c_ubyte),
            ("invert", ctypes.c_ubyte),
            ("gate", ctypes.c_ubyte),
            ("debug", ctypes.c_ubyte),
            ("delay", ctypes.c_uint64),
            ("width", ctypes.c_uint64),
            ("period", ctypes.c_uint64),
            ("burst", ctypes.c_uint64),
            ("cycle", ctypes.c_uint64),
            ("repeat", ctypes.c_uint64),
            ("count", ctypes.c_uint64),
            ("times", ctypes.c_uint64*MAX_SAMPLES),
        ]

    class _Sections(ctypes.Structure):
        _fields_ = [
            ("status", ctypes.c_ubyte*(8*8)),
            ("control", ctypes.c_ubyte*(1*8)),
            ("header", ctypes.c_ubyte*(7*8)),
            ("times", ctypes.c_uint64*MAX_SAMPLES),
        ]

    def __init__(self, iface):
        self.ptr = ctypes.c_void_p(0)
        iface.cdll.RPTRIG_GetDevice(ctypes.byref(self.ptr))

    @property
    def device(self):
        return ctypes.cast(
            self.ptr, ctypes.POINTER(struct_rptrig._Device)).contents

    @property
    def sections(self):
        return ctypes.cast(
            self.ptr, ctypes.POINTER(struct_rptrig._Sections)).contents

    @property
    def status(self):
        return tuple(self.sections.status)

    @property
    def control(self):
        return tuple(self.sections.control)

    @property
    def header(self):
        d = self.device
        return d.delay, d.width, d.period, d.burst, d.cycle, d.repeat, d.count

    @property
    def times(self):
        d = self.device
        return d.times[0:d.count]

    def __str__(self):
        return "rptrig" + str(self.header)

    def __repr__(self):
        return self.__class__.__name__ + "()"


# SERVER INTERFACE

class rptrig(object):
    _lock = threading.Lock()
    _NULL = ctypes.c_void_p(None)
    @staticmethod
    def _tobyte(val):
        if not isinstance(val, int):
            value = 0
            for ch in val:
                value |= 1 << ch
            return value
        return val

    @staticmethod
    def _toctypes(delay, width, period, burst, cycle, repeat, *args):
        delay = None if delay is None else ctypes.c_uint64(int(delay))
        width = None if width is None else ctypes.c_uint64(int(width))
        period = None if period is None else ctypes.c_uint64(int(period))
        burst = None if burst is None else ctypes.c_uint64(int(burst))
        cycle = None if cycle is None else ctypes.c_uint64(int(cycle))
        repeat = None if repeat is None else ctypes.c_uint32(int(repeat))
        if len(args) > 0:
            count = None if args[0] is None else ctypes.c_uint32(int(args[0]))
            return delay, width, period, burst, cycle, repeat, count
        return delay, width, period, burst, cycle, repeat

    @staticmethod
    def _byref(*args):
        return tuple(
            (rptrig._NULL if a is None else ctypes.byref(a))
            for a in args
        )

    def __init__(self):
        self._stop = False
        try:
            self.cdll = ctypes.CDLL('librptrig.so')
            self.cdll.RPTRIG_GetError.restype = ctypes.c_void_p
            self._error = ctypes.cast(
                    self.cdll.RPTRIG_GetError(), ctypes.c_char_p)
            self.dev = struct_rptrig(self)
            self.tryExt()
        except OSError as exc:
            print('rptrig: ' + str(exc))
            raise

    def tryExt(self):
        from time import sleep
        self.extclk(0)
        self.disarm()
        if not self.state & STATE_IDLE:
            print("Internal clock not idle?")
        self.extclk(1)
        self.arm()
        sleep(0.1)
        hasext = self.state & STATE_ARMED
        if not hasext:
            self.extclk(0)
        self.disarm()
        return hasext

    @property
    def status(self):
        status = self.dev.device.statusx[:]
        index = status[0]
        time = status[1] & TIME_MASK
        mask = status[1] >> TIME_WIDTH
        cycle, period, burst, repeat = status[2:6]
        flags = bin((status[6] & 0xFFFF) | (1 << 16))[3:]
        sigs = bin(((status[6] >> 56) & 0xFF) | (1 << 8))[3:]
        return index, time, mask, cycle, period, burst, repeat, flags, sigs

    def arm(self):
        self.cdll.RPTRIG_Arm()

    def rearm(self):
        self.cdll.RPTRIG_Rearm()

    def disarm(self):
        self.cdll.RPTRIG_Disarm()

    def makeClock(self,
                  delay=None, width=None, period=None,
                  burst=None, cycle=None, repeat=None):
        args = rptrig._toctypes(delay, width, period, burst, cycle, repeat)
        delay, width, period, burst, cycle, repeat = rptrig._byref(*args)
        self.cdll.RPTRIG_MakeClock(delay, width, period, burst, cycle, repeat)

    def makeSequence(self,
                     delay=None, width=None, period=None,
                     burst=None, cycle=None, repeat=None, times=(), mask=()):
        mask = numpy.array(
                [(m & 0xFF) << TIME_WIDTH for m in mask or [255]],
                dtype=numpy.uint64)
        lentimes, lenmask = len(times), len(mask)
        topad = lentimes - lenmask
        if topad > 0:
            mask = numpy.pad(mask, (0, topad), 'wrap')
        elif topad < 0:
            mask = mask[:lentimes]
        times = numpy.ascontiguousarray(times, dtype=numpy.uint64) & TIME_MASK
        times |= mask
        timref = times.ctypes.data_as(ctypes.POINTER(ctypes.c_uint64))
        buf = rptrig._toctypes(
            delay, width, period, burst, cycle, repeat, lentimes)
        delay, width, period, burst, cycle, repeat, count = rptrig._byref(*buf)
        self.cdll.RPTRIG_MakeSequence(
            delay, width, period, burst, cycle, repeat, count, timref)

    def reinit(self, delay=None):
        delay = None if delay is None else ctypes.c_uint64(int(delay))
        ref = rptrig._NULL if delay is None else ctypes.byref(delay)
        self.cdll.RPTRIG_Reinit(ref)

    def trig(self):
        self.cdll.RPTRIG_Trig()

    def extclk(self, value):
        self.cdll.RPTRIG_SetClockExt(
            ctypes.c_int8(-1) if value else ctypes.c_int8(0))

    def gate(self, value=0):
        value = rptrig._tobyte(value)
        self.cdll.RPTRIG_SetGate(ctypes.c_uint8(value))

    def debug(self, value=0):
        value = rptrig._tobyte(value)
        self.cdll.RPTRIG_SetDebug(ctypes.c_uint8(value))

    def invert(self, value=0):
        value = rptrig._tobyte(value)
        self.cdll.RPTRIG_SetInvert(ctypes.c_uint8(value))

    @property
    def error(self):
        return str(self._error.value)

    @property
    def state(self):
        return self.cdll.RPTRIG_GetState()

    @property
    def params(self):
        args = rptrig._toctypes(0, 0, 0, 0, 0, 0, 0)
        refs = rptrig._byref(*args)
        self.cdll.RPTRIG_GetParams(*refs)
        return tuple(int(a.value) for a in args)

    def stop(self):
        self._stop = True

    def run(self, port):
        try:  # create an AF_INET, STREAM socket (TCP)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as msg:
            print('Failed to create socket (%d): %s' % (msg[0], msg[1]))
            return
        try:
            sock.bind(('', int(port)))
        except socket.error as msg:
            print('Bind failed (%d): %s' % (msg[0], msg[1]))
            return
        try:
            sock.listen(5)
        except socket.error as msg:
            print('Listen failed (%d): %s' % (msg[0], msg[1]))
            return
        try:
            while not self._stop:
                try:
                    conn, addr = sock.accept()
                    rptrig.Handler(conn, addr, self).start()
                except KeyboardInterrupt:
                    raise
                except Exception as e:
                    print(e)
        finally:
            sock.close()
            with rptrig._lock:
                handlers = list(rptrig.Handler._set)
            for handler in handlers:
                handler.stop()
            for handler in handlers:
                handler.join()

    class Handler(threading.Thread):
        _set = set()

        def __init__(self, conn, addr, iface):
            super(rptrig.Handler, self).__init__(name='%s:%d' & addr)
            conn.settimeout(10)
            self.conn = conn
            self.iface = iface
            self._stop = False
            with rptrig._lock:
                rptrig.Handler._set.add(self)

        def stop(self):
            self._stop = True

        def senderror(self):
            msg = str(self.iface.error)
            self.conn.send(struct.pack('<L', len(msg))+msg)

        def run(self):
            try:
                print('%s : Connection established' % self.name)
                while not self._stop:
                    try:
                        head = self.conn.recv(7)
                        with rptrig._lock:
                            if not head.startswith('RPT'):
                                if len(head) > 0:
                                    raise Exception(
                                        'Invalid header "%s"' % (head, ))
                                raise Exception('Connection closed')
                            length = struct.unpack('<L', head[3:])[0]
                            remaining = length+1
                            cmd = []
                            while remaining > 0:
                                cmd.append(self.conn.recv(remaining+256))
                                remaining -= len(cmd[-1])
                            cmd = ''.join(cmd)
                            cmd, param = cmd[0], cmd[1:]
                            if cmd == 'C':
                                param = tuple((None if p<0 else p) for p in struct.unpack('<qqqqql', param[:44]))
                                self.iface.makeClock(*param)
                            elif cmd == 'S':
                                args = tuple((None if p<0 else p) for p in struct.unpack('<qqqqql', param[:44]))
                                times = numpy.fromstring(param[44:length], numpy.uint64)
                                self.iface.makeSequence(*args, times=times)
                            elif cmd == 'A':
                                self.iface.arm()
                            elif cmd == 'R':
                                self.iface.rearm()
                            elif cmd == 'X':
                                self.iface.reinit([(None if p<0 else p) for p in struct.unpack('<q', param[:8])][0])
                            elif cmd == 'D':
                                self.iface.disarm()
                            elif cmd == 'T':
                                self.iface.trig()
                            elif cmd == 'E':
                                self.iface.extclk(struct.unpack('<B', param[0])[0])
                            elif cmd == 'G':
                                self.iface.gate(struct.unpack('<B', param[0])[0])
                            elif cmd == 'I':
                                self.iface.invert(struct.unpack('<B', param[0])[0])
                            elif cmd == 'd':
                                self.iface.debug(struct.unpack('<B', param[0])[0])
                            elif cmd == 'c':
                                self.conn.send(struct.pack('<BBBBBBBB', *self.iface.dev.control))
                                continue
                            elif cmd == 's':
                                self.conn.send(struct.pack('<B', self.iface.state))
                                continue
                            elif cmd == 'p':
                                self.conn.send(struct.pack('<qqqqqll', *self.iface.params))
                                continue
                            elif cmd == 'e':
                                pass  # only return error
                            else:
                                raise Exception('Invalid command "%s"' % (cmd, ))
                            self.senderror()
                    except KeyboardInterrupt:
                        raise
                    except Exception as e:
                        print('%s : %s' % (self.name, str(e)))
                        break
            finally:
                self.conn.close()
                del(self.conn)
                with rptrig._lock:
                    rptrig.Handler._set.remove(self)


# UNIT TEST
class Test(unittest.TestCase):
    def local(self):
        from time import sleep
        dev = rptrig()
        dev.disarm()
        dev.reinit()
        sleep(.1)
        dev.disarm()
        dev.makeClock(cycle=10000000, burst=1000, repeat=5)
        self.assertEqual(dev.params, (0, 5, 10, 1000, 10000000, 5, 1))
        dev.makeSequence(1e6, 5, 10, 100, 1e6, 3, [0, 2e4, 4e4, 5e4, 7e4, 1e5])
        dev.gate([2, 4])
        # dev.debug([5])
        dev.invert([3, 4])
        dev.arm()
        dev.rearm()
        dev.trig()
        sleep(1)
        dev.disarm()

    def runTest(self):
        self.local()


def test():
    import os
    suite = unittest.TestSuite((Test('local'), ))
    tr = unittest.TextTestRunner(stream=os.sys.stderr)
    tr.run(suite)


# EXECUTION
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        try:
            port = int(sys.argv[1])
            rptrig().run(port)
        except ValueError:
            test()
    else:
        rptrig().run(5000)
